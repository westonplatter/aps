//! Markdown composition module for creating composite AGENTS.md files.
//!
//! This module provides functionality to merge multiple markdown files into
//! a single composite AGENTS.md file.

use crate::error::{ApsError, Result};
use std::path::Path;
use tracing::{debug, info};

/// Represents a resolved source file for composition
#[derive(Debug)]
pub struct ComposedSource {
    /// The path to the source file
    pub path: std::path::PathBuf,
    /// The content of the source file
    pub content: String,
    /// Optional label/name for this source (derived from filename)
    #[allow(dead_code)]
    pub label: String,
}

/// Options for composing markdown files
#[derive(Debug, Default)]
pub struct ComposeOptions {
    /// Add a separator comment between composed sections
    pub add_separators: bool,
    /// Include source file information as comments
    pub include_source_info: bool,
}

impl Default for ComposedSource {
    fn default() -> Self {
        Self {
            path: std::path::PathBuf::new(),
            content: String::new(),
            label: String::new(),
        }
    }
}

/// Read a markdown file and create a ComposedSource
pub fn read_source_file(path: &Path) -> Result<ComposedSource> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| ApsError::io(e, format!("Failed to read source file: {:?}", path)))?;

    let label = path
        .file_stem()
        .map(|s| s.to_string_lossy().to_string())
        .unwrap_or_else(|| "unknown".to_string());

    debug!("Read source file: {:?} ({} bytes)", path, content.len());

    Ok(ComposedSource {
        path: path.to_path_buf(),
        content,
        label,
    })
}

/// Compose multiple markdown files into a single string
pub fn compose_markdown(sources: &[ComposedSource], options: &ComposeOptions) -> Result<String> {
    if sources.is_empty() {
        return Err(ApsError::ComposeError {
            message: "No sources provided for composition".to_string(),
        });
    }

    info!("Composing {} markdown source(s)", sources.len());

    let mut result = String::new();

    // Add header comment
    result.push_str(
        "<!-- This file was auto-generated by aps (https://github.com/westonplatter/agentic-prompt-sync) -->\n\n",
    );

    for (i, source) in sources.iter().enumerate() {
        if i > 0 {
            // Add separator between sections
            result.push('\n');
            if options.add_separators {
                result.push_str("\n---\n\n");
            }
        }

        if options.include_source_info {
            result.push_str(&format!("<!-- Source: {} -->\n", source.path.display()));
        }

        // Add the content, trimming trailing whitespace but preserving structure
        let content = source.content.trim_end();
        result.push_str(content);
        result.push('\n');
    }

    debug!("Composed result: {} bytes", result.len());

    Ok(result)
}

/// Write the composed markdown to a destination file
pub fn write_composed_file(content: &str, dest: &Path) -> Result<()> {
    // Ensure parent directory exists
    if let Some(parent) = dest.parent() {
        if !parent.exists() {
            std::fs::create_dir_all(parent).map_err(|e| {
                ApsError::io(e, format!("Failed to create directory: {:?}", parent))
            })?;
        }
    }

    std::fs::write(dest, content)
        .map_err(|e| ApsError::io(e, format!("Failed to write composed file: {:?}", dest)))?;

    info!("Wrote composed file to {:?}", dest);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_compose_markdown_single_source() {
        let sources = vec![ComposedSource {
            path: std::path::PathBuf::from("test.md"),
            content: "# Test\n\nContent here".to_string(),
            label: "test".to_string(),
        }];

        let result = compose_markdown(&sources, &ComposeOptions::default()).unwrap();
        assert!(result.contains("# Test"));
        assert!(result.contains("Content here"));
        assert!(result.contains("auto-generated"));
    }

    #[test]
    fn test_compose_markdown_multiple_sources() {
        let sources = vec![
            ComposedSource {
                path: std::path::PathBuf::from("python.md"),
                content: "# Python\n\nPython content".to_string(),
                label: "python".to_string(),
            },
            ComposedSource {
                path: std::path::PathBuf::from("docker.md"),
                content: "# Docker\n\nDocker content".to_string(),
                label: "docker".to_string(),
            },
        ];

        let result = compose_markdown(&sources, &ComposeOptions::default()).unwrap();
        assert!(result.contains("# Python"));
        assert!(result.contains("Python content"));
        assert!(result.contains("# Docker"));
        assert!(result.contains("Docker content"));
    }

    #[test]
    fn test_compose_with_separators() {
        let sources = vec![
            ComposedSource {
                path: std::path::PathBuf::from("a.md"),
                content: "Section A".to_string(),
                label: "a".to_string(),
            },
            ComposedSource {
                path: std::path::PathBuf::from("b.md"),
                content: "Section B".to_string(),
                label: "b".to_string(),
            },
        ];

        let options = ComposeOptions {
            add_separators: true,
            include_source_info: false,
        };

        let result = compose_markdown(&sources, &options).unwrap();
        assert!(result.contains("---"));
    }

    #[test]
    fn test_compose_with_source_info() {
        let sources = vec![ComposedSource {
            path: std::path::PathBuf::from("/path/to/test.md"),
            content: "Content".to_string(),
            label: "test".to_string(),
        }];

        let options = ComposeOptions {
            add_separators: false,
            include_source_info: true,
        };

        let result = compose_markdown(&sources, &options).unwrap();
        assert!(result.contains("<!-- Source:"));
    }

    #[test]
    fn test_compose_empty_sources_error() {
        let sources: Vec<ComposedSource> = vec![];
        let result = compose_markdown(&sources, &ComposeOptions::default());
        assert!(result.is_err());
    }

    #[test]
    fn test_read_and_write_composed_file() {
        let dir = tempdir().unwrap();
        let source_path = dir.path().join("source.md");
        let dest_path = dir.path().join("AGENTS.md");

        // Write a test source file
        std::fs::write(&source_path, "# Test Agent\n\nDescription here").unwrap();

        // Read it
        let source = read_source_file(&source_path).unwrap();
        assert_eq!(source.label, "source");
        assert!(source.content.contains("Test Agent"));

        // Compose and write
        let composed = compose_markdown(&[source], &ComposeOptions::default()).unwrap();
        write_composed_file(&composed, &dest_path).unwrap();

        // Verify
        let written = std::fs::read_to_string(&dest_path).unwrap();
        assert!(written.contains("Test Agent"));
    }
}
